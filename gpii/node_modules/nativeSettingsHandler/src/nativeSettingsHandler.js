/*
 * OS Stubs Native Settings Handler
 *
 * Copyright 2020 Raising the Floor -- US Inc. All rights reserved.
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 * 
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 * 
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 */

"use strict";

var fluid = require("gpii-universal"),
    gpii = fluid.registerNamespace("gpii"),
    osstubs = fluid.registerNamespace("gpii.osstubs");

fluid.registerNamespace("gpii.osstubs.nativeSettingsHandler");

/**
 * Function that handles calling the native executable for volume control.
 *
 * @param {String} mode The operation mode, could be either "Set" or "Get".
 * @param {Number} [num] The value to set as the current system volume. Range is normalized from 0 to 1.
 * @return {Promise} A promise that resolves on success or holds a object with the error information.
 */
osstubs.nativeSettingsHandler.VolumeHandler = function (mode, num) {
    var promise = fluid.promise();

    try {
        var value;

        if (mode === "Get") {
            // return sample value; an actual implementation should retrieve the actual volume
            value = 0.5;
        } else {
            // NOTE: for compatibility with the reference Windows implementation, we return 0.0 here (instead of re-requesting the volume via osstubs.native.getAudioVolume())
            // option 1 (returning 0.0 to match the Windows implementation)
            value = 0.0;
            // option 2 (returning the actual new volume value)
            // value = 0.5; // sample value; an actual implementation should retrieve the actual volume
        }

        promise.resolve(value);
    } catch (err) {
        promise.reject(err);
    }

    return promise;
};

/**
 * Gets the current system volume
 *
 * @return {Promise} A promise that resolves on success or holds a object with the error information.
 */
osstubs.nativeSettingsHandler.GetVolume = function () {
    return osstubs.nativeSettingsHandler.VolumeHandler("Get");
};

/** The following source is included as a sample of implementing a Volume settings handler, but is not mandatory: Volume settings handlers may be implemented in various other way. */

// /**
//  * Sets the current system volume
//  *
//  * @param {Number} num The value to set as the current system volume. Range is normalized from 0 to 1.
//  * @return {Promise} A promise that resolves on success or holds a object with the error information.
//  */
// osstubs.nativeSettingsHandler.SetVolume = function (num) {
//     return osstubs.nativeSettingsHandler.VolumeHandler("Set", num);
// };

// osstubs.nativeSettingsHandler.functions = {
//     Volume: {
//         set: osstubs.nativeSettingsHandler.SetVolume,
//         get: osstubs.nativeSettingsHandler.GetVolume
//     }
// };

// /**
//  * Helper function that converts a error to string, so the rejection from the
//  * settings handler only holds a message.
//  *
//  * @param {Object} err The error to be stringified.
//  * @return {String} The error message.
//  */
// osstubs.nativeSettingsHandler.errorInfo = function (err) {
//     return "With error - '" + JSON.stringify(err) + "'";
// };

// /**
//  * Helper function for creating a custom message for error rejection.
//  *
//  * @param {Promise} promise The promise to be rejected.
//  * @param {String} settingKey The name of the requested setting for which an operation failed.
//  * @param {Object} err The error object.
//  * @param {String} message A message with information about the operation.
//  */
// osstubs.nativeSettingsHandler.reject = function (promise, settingKey, err, message) {
//     var operation = message + settingKey + "' failed. ";
//     var errMsg = "nativeSettingsHandler" + operation + osstubs.nativeSettingsHandler.errorInfo(err);

//     promise.reject(errMsg);
// };

// /**
//  * Setter for the nativeSettingsHandler.
//  *
//  * The payload should have the following format:
//  *
//  * {
//  *      "functionName": "FunctionName",
//  *      "setParam": val
//  * }
//  *
//  * The first two items:
//  *   - function: Function name for the function to be used to set/get the value.
//  *   - setParam: Parameter to be passed to the 'set' function.
//  *
//  * @param {Object} payload The payload.
//  * @return {Promise} Resolves with the response.
//  */
// osstubs.nativeSettingsHandler.setImpl = function (payload) {
//     var pRes = fluid.promise();

//     var fnName = fluid.get(payload, "options.functionName");
//     var setFn = fluid.get(osstubs.nativeSettingsHandler.functions, fnName + ".set");
//     var getFn = fluid.get(osstubs.nativeSettingsHandler.functions, fnName + ".get");
//     var fnNotDef = [": Failed due to '", " " + fnName + "' function not being defined."];

//     if (setFn === undefined) {
//         pRes.reject("nativeSettingsHandler" + fnNotDef[0] + "set" + fnNotDef[1]);
//     } else if (getFn === undefined) {
//         pRes.reject("nativeSettingsHandler" + fnNotDef[0] + "get" + fnNotDef[1]);
//     } else {
//         var results = {};
//         var settingsArray = fluid.makeArray(payload.settings);

//         if (settingsArray.length === 0) {
//             pRes.reject("nativeSettingsHandler: Failed due to empty payload.");
//         } else {
//             var uniqueSetting = settingsArray[0];
//             // Get the payload value to set.
//             var settingKey = fluid.keys(uniqueSetting)[0];
//             var valueToSet = fluid.values(uniqueSetting)[0].value;

//             // Create object for storing setting results.
//             results[settingKey] = {};
//             // Get the current values for the setting.
//             var pGetOld = getFn();

//             pGetOld.then(
//                 function (oldVal) {
//                     // Store the current value in results.
//                     fluid.set(results[settingKey], "oldValue.value", oldVal);

//                     var pSet = setFn(valueToSet);

//                     pSet.then(
//                         function () {
//                             var pGetNew = getFn();

//                             pGetNew.then(
//                                 function (newVal) {
//                                     fluid.set(results[settingKey], "newValue.value", newVal);

//                                     pRes.resolve(results);
//                                 },
//                                 function (err) {
//                                     osstubs.nativeSettingsHandler.reject(pRes, settingKey, err, ": Getting new value for setting '");
//                                 }
//                             );
//                         },
//                         function (err) {
//                             osstubs.nativeSettingsHandler.reject(pRes, settingKey, err, ": Setting new value for setting '");
//                         }
//                     );
//                 },
//                 function (err) {
//                     osstubs.nativeSettingsHandler.reject(pRes, settingKey, err, ": Getting current value for setting '");
//                 }
//             );
//         }
//     }

//     return pRes;
// };

// /**
//  * Getter for the nativeSettingsHandler.
//  *
//  * @param {Object} payload The payload.
//  * @return {Promise} Resolves with the response.
//  */
// osstubs.nativeSettingsHandler.getImpl = function (payload) {
//     var pRes = fluid.promise();

//     var fnName = fluid.get(payload, "options.functionName");
//     var getFn = fluid.get(osstubs.nativeSettingsHandler.functions, fnName + ".get");
//     var fnNotDef = [": Failed due to '", " " + fnName + "' function not being defined."];

//     if (getFn === undefined) {
//         pRes.reject("nativeSettingsHandler" + fnNotDef[0] + "get" + fnNotDef[1]);
//     } else {
//         var settingsArray = fluid.makeArray(payload.settings);

//         if (settingsArray.length === 0) {
//             pRes.reject("nativeSettingsHandler: Failed due to empty payload.");
//         } else {
//             var uniqueSetting = settingsArray[0];
//             var results = {};

//             // Get payload setting and prepare results for returning it
//             var settingKey = fluid.keys(uniqueSetting)[0];
//             results[settingKey] = {};

//             var pGetRes = getFn();

//             pGetRes.then(
//                 function (curVal) {
//                     results[settingKey].value = curVal;

//                     pRes.resolve(results);
//                 },
//                 function (err) {
//                     osstubs.nativeSettingsHandler.reject(pRes, settingKey, err, ": Getting current value for setting '");
//                 }
//             );
//         }
//     }

//     return pRes;
// };

// /**
//  * Invoke the settings handler.
//  *
//  * @param {Object} payload The payload
//  * @return {Promise} Resolves with the response.
//  */
// osstubs.nativeSettingsHandler.get = function (payload) {
//     return gpii.settingsHandlers.invokeSettingsHandler(osstubs.nativeSettingsHandler.getImpl, payload);
// };

// /**
//  * Invoke the settings handler.
//  *
//  * @param {Object} payload The payload
//  * @return {Promise} Resolves with the response.
//  */
// osstubs.nativeSettingsHandler.set = function (payload) {
//     return gpii.settingsHandlers.invokeSettingsHandler(osstubs.nativeSettingsHandler.setImpl, payload);
// };
